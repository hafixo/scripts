#!/usr/bin/env ruby

$LOAD_PATH.unshift(File.join(__dir__, "lib"))

require "csv"
require "erb"
require "shellwords"
require "timeout"

require "y2status"

module Report
  def print_progress(msg)
    $stderr.puts(msg) if Y2status::Options.instance.verbose
  end

  def print_error(msg)
    $stderr.puts(msg)
  end
end

module Downloader
  include Report

  def download_url(url)
    print_progress("Downloading #{url}...")
    # -s silent, -L follow redirects
    `curl --connect-timeout 15 --max-time 30 -sL #{Shellwords.escape(url)}`
  end
end

module HTML
  def status_symbol(obj)
    if obj.success?
      "<span class=\"color_success\">✔</span>"
    else
      "<span class=\"color_error\">✘</span>"
    end
  end
end

class ObsBuild
  attr_reader :package, :target, :status

  def initialize(package, target, status)
    @package = package
    @target = target
    @status = status
  end

  def status_label
    status
  end

  def status_type
    case status
    when "failed", "broken", "unresolvable"
      :error
    when "succeeded"
      :success
    when "disabled", "excluded"
      :unknown
    else
      :unknown
    end
  end
end

class ObsRequest
  attr_reader :id, :details

  def initialize(id, details)
    @id = id
    @details = details
  end
end

class ObsProject
  include Downloader
  include Report

  attr_reader :api, :name, :error_status, :error_requests

  def initialize(name, api = nil)
    @name = name
    @api = api
  end

  def builds
    @builds ||= download_builds
  end

  def declined_requests
    @requests ||= download_declined_requests
  end

  def project_url
    "#{web_url}/project/show/#{name}"
  end

  def web_url
    if api.nil?
      "https://build.opensuse.org"
    elsif api == "https://api.suse.de"
      "https://build.suse.de"
    else
      # fallback for an unknown OBS instance
      api
    end
  end

  def builds?
    !builds.any?{ |b| ["failed", "broken", "unresolvable"].include?(b.status) }
  end

  def declined?
    !declined_requests.empty?
  end

  def success?
     builds? && !declined?
  end

private

  attr_writer :status

  # Get the OBS project build state
  #
  # @param [String] project the project name
  # @param [String,nil] api the API URL
  #
  # @return [CSV::Table] the parsed table
  #
  def download_builds
    opt = api ? "-A #{Shellwords.escape(api)} " : ""
    cmd = "osc #{opt}prjresults --csv #{Shellwords.escape(name)}"

    print_progress("Running \"#{cmd}\"...")

    begin
      str = Timeout.timeout(15) { `#{cmd}` }
    rescue Timeout::Error
      @error_status = "ERROR: Command #{cmd} timed out"
      print_error(@error_status)
      return []
    end

    table = CSV.parse(str, col_sep: ";", headers: true)

    table.each_with_object([]) do |row, list|
      row.each do |name, status|
        # skip the name pair from the header
        next if name == "_"

        package = row["_"]
        target = name.sub(/\/[^\/]*$/, "")

        list << ObsBuild.new(package, target, status)
      end
    end
  end

  def download_declined_requests
    opt = api ? "-A #{Shellwords.escape(api)} " : ""
    cmd = "osc #{opt}request list -s declined #{Shellwords.escape(name)}"

    print_progress("Running \"#{cmd}\"...")

    begin
      out = Timeout.timeout(15) { `#{cmd}` }
    rescue Timeout::Error
      @error_status = "ERROR: Command #{cmd} timed out"
      print_error(error_status)
      return []
    end

    # the requests are separated by empty lines
    out.split("\n\n").each_with_object([]) do |r, list|
      if r.match(/\A(\d+).*\n\s*(?:maintenance_incident|submit): (.*?)\n/m)
        # remove repeated spaces by #squeeze
        list << ObsRequest.new(Regexp.last_match[1], Regexp.last_match[2].strip.squeeze(" "))
      end
    end
  end
end

def render_erb(template, bind)
  include ERB::Util
  include HTML

  file = File.join(__dir__, "views", template)
  renderer = ERB.new(File.read(file))
  renderer.filename = file
  renderer.result(bind)
end

###################################################################################################

jenkins_servers = [
  Y2status::JenkinsServer.new("External Jenkins", "https://ci.opensuse.org/view/Yast")
]

if !Y2status::Options.instance.public_only
  # internal Jenkins status
  jenkins_servers << Y2status::JenkinsServer.new("Internal Jenkins", "https://ci.suse.de/view/YaST")
end

# OBS
obs_projects = ["YaST:Head", "YaST:SLE-15:GA", "YaST:SLE-12:SP4", "YaST:SLE-12:SP3" ].map do |p|
  ObsProject.new(p)
end

obs_partial = render_erb("_obs.html.erb", binding)

# IBS
if !Y2status::Options.instance.public_only
  obs_projects = ["Devel:YaST:CASP:4.0", "Devel:YaST:SLE-12-SP3", "Devel:YaST:SLE-12-SP4",
    "Devel:YaST:SLE-15", "Devel:YaST:Head"].map do |p|
    ObsProject.new(p, "https://api.suse.de")
  end

  obs_partial += render_erb("_obs.html.erb", binding)
end


docker_images = ["yastdevel/ruby", "yastdevel/cpp", "yastdevel/libstorage-ng", "libyui/devel"].map do |i|
  Y2status::DockerImage.new(i)
end

jenkins_partial = render_erb("_jenkins.html.erb", binding)
docker_partial = render_erb("_docker.html.erb", binding)

body = render_erb("index.html.erb", binding)
puts render_erb("layout.html.erb", binding)

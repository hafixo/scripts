#!/usr/bin/env ruby

require "cgi"
require "csv"
require "erb"
require "json"
require "optparse"
require "shellwords"
require "singleton"
require "timeout"

# parse and store the command line options
class Options
  include Singleton

  attr_reader :verbose, :public_only

  def initialize
    @only_errors = true

    OptionParser.new do |opts|
      opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

      opts.on("-p", "--public", "Query only the public services (default: false)") do |p|
        @public_only = p
      end

      opts.on("-v", "--[no-]verbose", "Run verbosely (default: false)") do |v|
        @verbose = v
      end

    end.parse!
  end
end

module Report
  def print_progress(msg)
    $stderr.puts(msg) if Options.instance.verbose
  end

  def print_error(msg)
    puts message(msg, :error)
    $stderr.puts(msg)
  end
end

def print_line(line, success)
  print "<pre class=\"output_line #{success ? "success_line" : ""}\">"
  print line
  puts "</pre>"
end

module Downloader
  def download_url(url)
    print_progress("Downloading #{url}...")
    # -s silent, -L follow redirects
    `curl --connect-timeout 15 --max-time 30 -sL #{Shellwords.escape(url)}`
  end
end

class Jenkins
  include Downloader
  include Report

  attr_reader :base_url, :label, :error

  def initialize(label, base_url)
    @label = label
    @base_url = base_url
  end

  def success?
    jobs.all?{ |j| j.status != "red"}
  end

  def jobs
    @jobs ||= download
  end

  def console_url(job)
    "#{base_url}/job/#{job}/lastBuild/console"
  end

private

  def status_url
    "#{base_url}/api/json?pretty=true"
  end

  def download
    body = download_url(status_url)

    if body.empty?
      @error = "ERROR: Cannot download #{status_url}"
      print_error(error)
      return {}
    end

    job_list = []

    data = JSON.parse(body)
    data["jobs"].each do |s|
      job_list << JenkinsJob.new(s["name"], s["color"])
    end

    job_list
  end
end

class JenkinsJob
  attr_reader :name, :status

  def initialize(name, status)
    @name = name
    @status = status
  end

  def status_label
    case status
    when "red"
      "failed"
    when "blue"
      "success"
    else
      status
    end
  end

  def status_type
    case status
    when "red"
      :error
    when "blue"
      :success
    when "disabled"
      :info
    else
      :unknown
    end
  end
end


class Obs
  include Downloader
  include Report

  attr_reader :api, :project, :status, :requests

  def initialize(project, api)
    @project = project
    @api = api
  end

private

  attr_writer :status

  # Get the OBS project build state
  #
  # @param [String] project the project name
  # @param [String,nil] api the API URL
  #
  # @return [CSV::Table] the parsed table
  #
  def get_obs_status
    opt = api ? "-A #{Shellwords.escape(api)}" : ""
    cmd = "osc #{opt} prjresults --csv #{Shellwords.escape(project)}"

    print_progress("Running \"#{cmd}\"...")

    begin
      str = Timeout.timeout(15) { `#{cmd}` }
    rescue Timeout::Error
      print_error("ERROR: Command #{cmd} timed out")
      str = ""
    end

    self.status = CSV.parse(str, col_sep: ";", headers: true)
  end

  def declined_requests
    opt = api ? "-A #{Shellwords.escape(api)}" : ""
    cmd = "osc #{opt} request list -s declined #{Shellwords.escape(project)}"

    print_progress("Running \"#{cmd}\"...")

    begin
      out = Timeout.timeout(15) { `#{cmd}` }
    rescue Timeout::Error
      print_error("ERROR: Command #{cmd} timed out")
      out = ""
    end

    # the requests are separated by empty lines
    out.split("\n\n").each do |r|
      if r.match(/\A(\d+).*\n\s*(?:maintenance_incident|submit): (.*?)\n/m)
        requests[Regexp.last_match[1]] = Regexp.last_match[2].strip
      end
    end
  end
end

def jenkins_status(title, base_url)
  print_header(title, base_url)

  url = base_url + "/api/json?pretty=true"
  body = download(url)

  if body.empty?
    print_error("ERROR: Cannot download #{url}")
    return false
  end

  status = JSON.parse(body)

  status["jobs"].each do |s|
    link = "#{base_url}/job/#{s["name"]}/lastBuild/console)"

    msg = sprintf("    %-50s  ", s["name"])
    msg << case s["color"]
    when "red"
      message("failed", :error, link)
    when "blue"
      message("success", :success, link)
    when "disabled"
      message("disabled", :info, link)
    else
      message(s["color"], :unknown, link)
    end

    print_line(msg, s["color"] != "red")
  end
end

#
# Get the OBS project build state
#
# @param [String] project the project name
# @param [String,nil] api the API URL
#
# @return [CSV::Table] the parsed table
#
def get_obs_status(project, api = nil)
  opt = api ? "-A #{Shellwords.escape(api)}" : ""
  cmd = "osc #{opt} prjresults --csv #{Shellwords.escape(project)}"

  print_progress("Running \"#{cmd}\"...")

  begin
    str = Timeout.timeout(15) { `#{cmd}` }
  rescue Timeout::Error
    print_error("ERROR: Command #{cmd} timed out")
    str = ""
  end

  CSV.parse(str, col_sep: ";", headers: true)
end

def obs_api_to_web(api)
  if api.nil?
    "https://build.opensuse.org"
  elsif api == "https://api.suse.de"
    "https://build.suse.de"
  else
    api
  end
end

def print_obs_header(project, api)
  type = (api == "https://api.suse.de") ? "IBS" : "OBS"
  print_header("#{type} #{project}", "#{obs_api_to_web(api)}/project/show/#{project}")
end

def print_obs_request_header(project, api)
  print_sub_header("Declined Submit Requests", "#{obs_api_to_web(api)}/project/requests/#{project}")
end

def declined_requests(project, api=nil)
  opt = api ? "-A #{Shellwords.escape(api)}" : ""
  cmd = "osc #{opt} request list -s declined #{Shellwords.escape(project)}"

  print_progress("Running \"#{cmd}\"...")

  begin
    out = Timeout.timeout(15) { `#{cmd}` }
  rescue Timeout::Error
    print_error("ERROR: Command #{cmd} timed out")
    out = ""
  end

  # the requests are separated by empty lines
  requests = out.split("\n\n")

  ret = {}
  requests.each do |r|
    if r.match(/\A(\d+).*\n\s*(?:maintenance_incident|submit): (.*?)\n/m)
      ret[Regexp.last_match[1]] = Regexp.last_match[2].strip
    end
  end

  ret
end

def print_declined_requests(project, api=nil)
  print_obs_request_header(project, api)
  declined = declined_requests(project, api)

  declined.each do |num, name|
    link = "#{obs_api_to_web(api)}/request/show/#{num}"
    msg = sprintf("    %-7s  %-90s  %s", html_link(num, link), name, message("declined", :error, link))
    print_line(msg, false)
  end
end

def print_obs_status(project, api = nil)
  print_obs_header(project, api)
  print_sub_header("Build Results", "#{obs_api_to_web(api)}/project/monitor/#{project}")

  table = get_obs_status(project, api)

  table.each do |row|
    row.each do |name, value|
      # skip the name pair
      next if name == "_"

      package = row["_"]
      target = name.sub(/\/[^\/]*$/, "")
      msg = sprintf("    %-35s  %-30s  ", package, target)

      path = (value == "failed") ? "package/live_build_log" : "package/show"
      target = "" if value != "failed"
      link = "#{obs_api_to_web(api)}/#{path}/#{project}/#{package}/#{target}"

      msg << if value == "succeeded"
               message(value, :success, link)
             elsif ["failed", "broken", "unresolvable"].include?(value)
               message(value, :error, link)
             else
               message(value, :unknown)
      end

      print_line(msg, !["failed", "broken", "unresolvable"].include?(value))
    end
  end

  print_declined_requests(project, api)
end

def docker_status_url(img)
  "https://hub.docker.com/v2/repositories/#{img}/buildhistory/?page_size=250"
end

def html_link(text, url)
  ret = ""
  ret << "<a href=\"#{CGI.escapeHTML(url)}\">" if url
  ret << CGI.escapeHTML(text)
  ret << "</a>" if url
  ret
end

def message(msg, type, url = nil)
  ret = ""
  ret << "<span class=\"#{CGI.escapeHTML(type.to_s)} badge\">"
  ret << html_link(msg, url)
  ret << "</span>"
  ret
end

def print_docker_image_status(img, result)
  link = "https://hub.docker.com/r/#{img}/builds/#{result["build_code"]}/"
  msg = sprintf("    %-50s  ", result["dockertag_name"])

  # "status" values:
  #     -1 = failed
  #   0..9 = building
  #     10 = success
  msg << case result["status"]
  when -1
    message("failed", :error, link)
  when 10
    message("success", :success, link)
  when 0..9
    message("building", :info, link)
  else
    message("unknown", :unknown, link)
  end

  print_line(msg, result["status"] != -1)
end

def print_dockerhub_status(img)
  print_header("Docker Hub #{img}", "https://hub.docker.com/r/#{img}/")

  url = docker_status_url(img)
  body = download(url)

  if body.empty?
    print_error("ERROR: Cannot download #{url}")
    return false
  end

  status = JSON.parse(body)

  # remove the duplicates, we need just the latest result for each tag
  results = status["results"]
  results.uniq! { |r| r["dockertag_name"] }

  results.each do |r|
    print_docker_image_status(img, r)
  end
end

def print_header(title, url = nil)
  print "<h2>"
  print "<a href=\"#{CGI.escapeHTML(url)}\">" if url
  print CGI.escapeHTML(title)
  print "</a>" if url
  puts "</h2>"
end

def print_sub_header(title, url = nil)
  print "<h4>"
  print "<a href=\"#{CGI.escapeHTML(url)}\">" if url
  print CGI.escapeHTML(title)
  print "</a>" if url
  puts "</h4>"
end

def render_erb(template, bind)
  include ERB::Util
  file = File.join(__dir__, template)
  renderer = ERB.new(File.read(file))
  renderer.filename = template
  renderer.result(bind)
end

###################################################################################################

template = "#{__dir__}/index.html.erb"
renderer = ERB.new(File.read(template))
renderer.filename = template

jenkins_servers = [
  Jenkins.new("External Jenkins", "https://ci.opensuse.org/view/Yast")
]

if !Options.instance.public_only
  # internal Jenkins status
  jenkins_servers << Jenkins.new("Internal Jenkins", "https://ci.suse.de/view/YaST")
end

body = render_erb("_jenkins.html.erb", binding)
puts render_erb("index.html.erb", binding)

exit 0

if !Options.instance.public_only
  # internal Jenkins status
  jenkins_status("Internal Jenkins", "https://ci.suse.de/view/YaST")
end

# external Jenkins status
jenkins_status("External Jenkins", "https://ci.opensuse.org/view/Yast")

# OBS
obs = ["YaST:SLE-12:SP3", "YaST:SLE-12:SP4", "YaST:SLE-15:GA", "YaST:Head"]
obs.each { |r| print_obs_status(r) }

# IBS
if !Options.instance.public_only
  api = "https://api.suse.de"
  ibs = ["Devel:YaST:CASP:4.0", "Devel:YaST:SLE-12-SP3", "Devel:YaST:SLE-12-SP4",
         "Devel:YaST:SLE-15", "Devel:YaST:Head"]
  ibs.each { |r| print_obs_status(r, api) }
end

# Docker Hub status
imgs = ["yastdevel/ruby", "yastdevel/cpp", "yastdevel/libstorage-ng", "libyui/devel"]
imgs.each { |i| print_dockerhub_status(i) }

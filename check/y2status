#!/usr/bin/env ruby

require "cgi"
require "csv"
require "erb"
require "json"
require "optparse"
require "shellwords"
require "singleton"
require "timeout"

# parse and store the command line options
class Options
  include Singleton

  attr_reader :verbose, :public_only

  def initialize
    OptionParser.new do |opts|
      opts.banner = "Usage: #{$PROGRAM_NAME} [options]"

      opts.on("-p", "--public", "Query only the public services (default: false)") do |p|
        @public_only = p
      end

      opts.on("-v", "--[no-]verbose", "Run verbosely (default: false)") do |v|
        @verbose = v
      end

    end.parse!
  end
end

module Report
  def print_progress(msg)
    $stderr.puts(msg) if Options.instance.verbose
  end

  def print_error(msg)
    $stderr.puts(msg)
  end
end

module Downloader
  def download_url(url)
    print_progress("Downloading #{url}...")
    # -s silent, -L follow redirects
    `curl --connect-timeout 15 --max-time 30 -sL #{Shellwords.escape(url)}`
  end
end

module HTML
  def status_symbol(obj)
    "<span class=\"#{obj.success? ? "success" : "failed"}_mark\"></span>"
  end
end

class Jenkins
  include Downloader
  include Report

  attr_reader :base_url, :label, :error

  def initialize(label, base_url)
    @label = label
    @base_url = base_url
  end

  def success?
    jobs.all?{ |j| j.status != "red"}
  end

  def jobs
    @jobs ||= download
  end

  def console_url(job)
    "#{base_url}/job/#{job}/lastBuild/console"
  end

private

  def status_url
    "#{base_url}/api/json?pretty=true"
  end

  def download
    body = download_url(status_url)

    if body.empty?
      @error = "Cannot download #{status_url}"
      print_error(error)
      return []
    end

    data = JSON.parse(body)
    data["jobs"].map do |s|
      JenkinsJob.new(s["name"], s["color"])
    end
  end
end

class JenkinsJob
  attr_reader :name, :status

  def initialize(name, status)
    @name = name
    @status = status
  end

  def status_label
    case status
    when "red"
      "failed"
    when "blue"
      "success"
    else
      status
    end
  end

  def status_type
    case status
    when "red"
      :error
    when "blue"
      :success
    when "disabled"
      :info
    else
      :unknown
    end
  end
end

class ObsBuild
  attr_reader :package, :target, :status

  def initialize(package, target, status)
    @package = package
    @target = target
    @status = status
  end

  def status_label
    status
  end

  def status_type
    case status
    when "failed", "broken", "unresolvable"
      :error
    when "succeeded"
      :success
    when "disabled", "excluded"
      :info
    else
      :unknown
    end
  end
end

class ObsRequest
  attr_reader :id, :details

  def initialize(id, details)
    @id = id
    @details = details
  end
end

class ObsProject
  include Downloader
  include Report

  attr_reader :api, :name, :error_status, :error_requests

  def initialize(name, api = nil)
    @name = name
    @api = api
  end

  def builds
    @builds ||= download_builds
  end

  def declined_requests
    @requests ||= download_declined_requests
  end

  def project_url
    "#{web_url}/project/show/#{name}"
  end

  def web_url
    if api.nil?
      "https://build.opensuse.org"
    elsif api == "https://api.suse.de"
      "https://build.suse.de"
    else
      # fallback for an unknown OBS instance
      api
    end
  end

  def builds?
    !builds.any?{ |b| ["failed", "broken", "unresolvable"].include?(b.status) }
  end

  def declined?
    !declined_requests.empty?
  end

  def success?
     builds? && !declined?
  end

private

  attr_writer :status

  # Get the OBS project build state
  #
  # @param [String] project the project name
  # @param [String,nil] api the API URL
  #
  # @return [CSV::Table] the parsed table
  #
  def download_builds
    opt = api ? "-A #{Shellwords.escape(api)} " : ""
    cmd = "osc #{opt}prjresults --csv #{Shellwords.escape(name)}"

    print_progress("Running \"#{cmd}\"...")

    begin
      str = Timeout.timeout(15) { `#{cmd}` }
    rescue Timeout::Error
      @error_status = "ERROR: Command #{cmd} timed out"
      print_error(@error_status)
      return []
    end

    table = CSV.parse(str, col_sep: ";", headers: true)

    table.each_with_object([]) do |row, list|
      row.each do |name, status|
        # skip the name pair from the header
        next if name == "_"

        package = row["_"]
        target = name.sub(/\/[^\/]*$/, "")

        list << ObsBuild.new(package, target, status)
      end
    end
  end

  def download_declined_requests
    opt = api ? "-A #{Shellwords.escape(api)} " : ""
    cmd = "osc #{opt}request list -s declined #{Shellwords.escape(name)}"

    print_progress("Running \"#{cmd}\"...")

    begin
      out = Timeout.timeout(15) { `#{cmd}` }
    rescue Timeout::Error
      @error_status = "ERROR: Command #{cmd} timed out"
      print_error(error_status)
      return []
    end

    # the requests are separated by empty lines
    out.split("\n\n").each_with_object([]) do |r, list|
      if r.match(/\A(\d+).*\n\s*(?:maintenance_incident|submit): (.*?)\n/m)
        # remove repeated spaces by #squeeze
        list << ObsRequest.new(Regexp.last_match[1], Regexp.last_match[2].strip.squeeze(" "))
      end
    end
  end
end



def print_obs_header(project, api)
  type = (api == "https://api.suse.de") ? "IBS" : "OBS"
  print_header("#{type} #{project}", "#{obs_api_to_web(api)}/project/show/#{project}")
end

def print_obs_request_header(project, api)
  print_sub_header("Declined Submit Requests", "#{obs_api_to_web(api)}/project/requests/#{project}")
end


def print_declined_requests(project, api=nil)
  print_obs_request_header(project, api)
  declined = declined_requests(project, api)

  declined.each do |num, name|
    link = "#{obs_api_to_web(api)}/request/show/#{num}"
    msg = sprintf("    %-7s  %-90s  %s", html_link(num, link), name, message("declined", :error, link))
    print_line(msg, false)
  end
end

def print_obs_status(project, api = nil)
  print_obs_header(project, api)
  print_sub_header("Build Results", "#{obs_api_to_web(api)}/project/monitor/#{project}")

  table = get_obs_status(project, api)

  table.each do |row|
    row.each do |name, value|
      # skip the name pair
      next if name == "_"

      package = row["_"]
      target = name.sub(/\/[^\/]*$/, "")
      msg = sprintf("    %-35s  %-30s  ", package, target)

      path = (value == "failed") ? "package/live_build_log" : "package/show"
      target = "" if value != "failed"
      link = "#{obs_api_to_web(api)}/#{path}/#{project}/#{package}/#{target}"

      msg << if value == "succeeded"
               message(value, :success, link)
             elsif ["failed", "broken", "unresolvable"].include?(value)
               message(value, :error, link)
             else
               message(value, :unknown)
      end

      print_line(msg, !["failed", "broken", "unresolvable"].include?(value))
    end
  end

  print_declined_requests(project, api)
end

class DockerBuild
  attr_reader :tag, :status

  def initialize(tag, status)
    @tag = tag
    @status = status
  end

  def status_label
    # "status" values:
    #     -1 = failed
    #   0..9 = building
    #     10 = success
    case status
    when -1
      "failed"
    when 10
      "success"
    when 0..9
      "building"
    else
      "unknown"
    end
  end

  def status_type
    case status
    when -1
      :error
    when 10
      :success
    when 0..9
      :info
    else
      :unknown
    end
  end
end

class DockerImage
  include Downloader
  include Report

  attr_reader :image, :error

  def initialize(image)
    @image = image
  end

  def builds
    @builds ||= download
  end

  def success?
    builds.all?{ |b| b.status != -1 }
  end

  private

  def docker_status_url
    "https://hub.docker.com/v2/repositories/#{image}/buildhistory/?page_size=250"
  end

  def download
    body = download_url(docker_status_url)

    if body.empty?
      @error = "Cannot download the build status"
      print_error(error)
      return []
    end

    status = JSON.parse(body)

    # remove the duplicates, we need just the latest result for each tag
    results = status["results"]
    results.uniq! { |r| r["dockertag_name"] }

    results.map do |r|
      DockerBuild.new(r["dockertag_name"], r["status"])
    end
  end
end

def render_erb(template, bind)
  include ERB::Util
  include HTML

  file = File.join(__dir__, template)
  renderer = ERB.new(File.read(file))
  renderer.filename = template
  renderer.result(bind)
end

###################################################################################################

template = "#{__dir__}/index.html.erb"
renderer = ERB.new(File.read(template))
renderer.filename = template

jenkins_servers = [
  Jenkins.new("External Jenkins", "https://ci.opensuse.org/view/Yast")
]

if !Options.instance.public_only
  # internal Jenkins status
  jenkins_servers << Jenkins.new("Internal Jenkins", "https://ci.suse.de/view/YaST")
end


# OBS
obs_projects = ["YaST:Head", "YaST:SLE-15:GA", "YaST:SLE-12:SP4", "YaST:SLE-12:SP3" ].map do |p|
  ObsProject.new(p)
end

obs_partial = render_erb("_obs.html.erb", binding)

# IBS
if !Options.instance.public_only
  obs_projects = ["Devel:YaST:CASP:4.0", "Devel:YaST:SLE-12-SP3", "Devel:YaST:SLE-12-SP4",
    "Devel:YaST:SLE-15", "Devel:YaST:Head"].map do |p|
    ObsProject.new(p, "https://api.suse.de")
  end

  obs_partial += render_erb("_obs.html.erb", binding)
end


docker_images = ["yastdevel/ruby", "yastdevel/cpp", "yastdevel/libstorage-ng", "libyui/devel"].map do |i|
  DockerImage.new(i)
end

jenkins_partial = render_erb("_jenkins.html.erb", binding)
docker_partial = render_erb("_docker.html.erb", binding)

body = render_erb("_main.html.erb", binding)
puts render_erb("index.html.erb", binding)

exit 0



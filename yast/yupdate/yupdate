#!/usr/bin/env ruby

# This script updates the YaST files in the inst-sys
# with the files from GitHub.
# See the help text below for the details.

require "digest/sha1"
require "fileutils"
require "find"
require "json"
require "logger"
require "net/http"
require "pathname"
require "shellwords"
require "singleton"
require "socket"
require "tmpdir"
require "uri"

SELF_UPDATE_URL = "https://raw.githubusercontent.com/lslezak/scripts/master/yast/yupdate/yupdate"

# handle the "help" command line option
class HelpCommand
  def run
    name = File.basename($PROGRAM_NAME)
    puts <<-HELP
This is a helper script for updating the YaST installer in the installation system.

Usage:

#{name} <command>

Commands:

patch <github_repo> <branch>
patch <tarball_url>
patch <host[:port]>

servers <host[:port]>   List the rake servers running on the remote machine

overlay create [<dir>]  Create a new writable overlay for directory <dir>,
                        if no directory is specified it creates overlays
                        for the default YaST directories
overlay list            Print the created writable overlays

overlay reset           Remove all writable overlays, restore the system to
                        the original state

overlay files           Print the changed files (removed files are not listed)

overlay diff            Print the diff of the changed overlay files

selfupdate              Update the script itself from
                        #{SELF_UPDATE_URL}
version                 Print the script version

help                    Print this help

WARNING: This script is intended only for testing and development purposes,
         using this tool makes the installation not supported!
See more details in [TODO README URL]
HELP
  end
end

# A Ruby Logger which logs in usual Yast y2log format,
# additionally it prints the messages also to STDOUT
class YastLogger < Logger
  # redefine the format to the y2log format
  def format_message(severity, timestamp, progname, msg)
    puts msg
    # remove the function name from the caller location
    location = caller(3).first.gsub(/:in `.*'$/, "")
    "#{timestamp.strftime(datetime_format)} #{severity} #{Socket.gethostname}(#{Process.pid}) #{progname} #{location} #{msg}\n"
  end

  def initialize(*args)
    super
    self.datetime_format = "%Y-%m-%d %H:%M:%S"
    self.progname = "[#{File.basename($PROGRAM_NAME)}]"
    self.level = ENV["Y2DEBUG"] == "1" ? Logger::DEBUG : Logger::INFO
  end

private

  # redefine severity formatting
  def format_severity(severity)
    "<#{severity}>"
  end
end

# Provides the global shared Y2logger instance writing to /var/log/YaST2/y2log
# (or ~/.y2log if the file is not writable).
#
# It can be used for logging external Ruby code into y2log
class Y2Logger
  include Singleton

  Y2LOGFILE = "/var/log/YaST2/y2log".freeze

  attr_accessor :log

  def initialize
    # Yast compatibility - log to home if not running as root
    # (or if the file is not writable)
    if File.exist?(Y2LOGFILE)
      # is the file writable?
      log_file = File.writable?(Y2LOGFILE) ? Y2LOGFILE : "#{ENV["HOME"]}/.y2log"
    else
      # is the parent directory writable?
      log_file = File.writable?(File.dirname(Y2LOGFILE)) ? Y2LOGFILE : "#{ENV["HOME"]}/.y2log"
    end

    # when creating the log file make sure it is readable only by the user
    # (it might contain sensitive data like passwords, registration code, etc.)
    File.write(log_file, "", perm: 0o600) unless File.exist?(log_file)

    @log = YastLogger.new(log_file)
  end
end

# This module provides access to Yast specific logging
#
# @example Use YastLogger in an easy way
#   class Foo
#     include YLogger
#
#     def foo
#       # this will be logged into y2log using the usual y2log format
#       log.debug "debug"
#       log.error "error"
#     end
#   end
module YLogger
  def log
    Y2Logger.instance.log
  end

  def self.included(base)
    base.extend self
  end
end

# version of the script
class Version
  STRING = "0.90.0"

  # @return [String] the version string including the SHA1 sum
  #   to distinguish any change in the file
  def self.string
    sha = Digest::SHA1.hexdigest(File.read($PROGRAM_NAME))[0..7]
    "#{STRING} (#{sha})"
  end
end

# a simple /etc/install.inf parser/writer
class InstallInf
  attr_reader :path

  # read the file
  def initialize(path = "/etc/install.inf")
    @path = path
    @values = File.read(path).lines.map(&:chomp)
  end

  # get value for the key
  def [](key)
    line = find_line(key)
    return nil unless line

    line.match(/^#{Regexp.escape(key)}:\s*(.*)/)[1]
  end

  # set value for the key
  def []=(key, val)
    line = find_line(key)

    if line
      # update the existing key
      line.replace("#{key}: #{val}")
    else
      # add a new key
      values << "#{key}: #{val}"
    end
  end

  # write the file back
  def write
    File.write(path, values.join("\n"))
  end

private

  attr_reader :values

  def find_line(key)
    values.find{ |l| l.start_with?(key + ":") }
  end
end

# Class for managing the OverlayFS mounts
class OverlayFS
  include YLogger

  OVERLAY_PREFIX = "/var/lib/YaST2/overlayfs".freeze

  YAST_OVERLAYS = [
    "/usr/lib/YaST2",
    "/usr/lib64/YaST2",
    "/usr/share/autoinstall",
    "/usr/share/applications/YaST2"
  ]

  attr_reader :dir

  # manage the OverlayFS for this directory
  def initialize(dir)
    # expand symlinks
    @dir = File.realpath(dir)
  end

  # create an OverlayFS overlay for this directory if it is not writable
  def create
    return if File.writable?(dir)
    log.warn "Adding overlay for #{dir}..."

    FileUtils.mkdir_p(upperdir)
    FileUtils.mkdir_p(workdir)
    FileUtils.mkdir_p(origdir)

    # make the original content available in a separate directory
    system("mount --bind #{dir.shellescape} #{origdir.shellescape}")
    # mark the mount as a private otherwise the overlay would propagate
    # through the bind mount and we would see the changed content here
    system("mount --make-private #{origdir.shellescape}")

    system("mount -t overlay overlay -o lowerdir=#{dir.shellescape}," \
      "upperdir=#{upperdir.shellescape},workdir=#{workdir.shellescape} #{dir.shellescape}")
  end

  # delete the OverlayFS for this directory, all changes will be lost
  def delete
    log.debug "umount #{dir}"
    system "umount #{dir.shellescape}"

    log.debug "umount #{origdir}"
    system "umount #{origdir.shellescape}"

    FileUtils.rm_rf([ upperdir, workdir, origdir ])
  end

  # print the modified files in this directory
  def print_files
    modified_files { |f, _modif, _orig| puts f}
  end

  # print the diff for the changed files in this directory
  def print_diff
    modified_files do |f, _modif, orig|
      next unless File.exist?(f) && File.exist?(orig)
      system("diff -u #{orig.shellescape} #{f.shellescape}")
    end
  end

  # find all OverlayFS mounts in the system
  def self.find_all
    mounts = `mount`
    mounts.lines.each_with_object([]) do |line, arr|
      arr << new(Regexp.last_match[1]) if line =~ /^overlay on (.*) type overlay /
    end
  end

  # return the default set of YaST overlays
  def self.default_overlays
    yast_overlays.map{ |o| new(o) }
  end

private

  def dir_name
    # escape _ (double) for correct reverse conversion
    dir.gsub("_", "__").tr("/", "_")
  end

  def upperdir
    File.join(OVERLAY_PREFIX, "upper", dir_name)
  end

  def workdir
    File.join(OVERLAY_PREFIX, "workdir", dir_name)
  end

  def origdir
    File.join(OVERLAY_PREFIX, "original", dir_name)
  end

  # find the modified files in this directory
  def modified_files(&block)
    return unless block_given?

    Find.find(upperdir) do |f|
      next unless File.file?(f)
      upperdir_path = Pathname.new(upperdir)
      relative_path = Pathname.new(f).relative_path_from(upperdir_path)
      original_path = File.join(origdir, relative_path)
      # unescape _
      pth = upperdir_path.basename.to_s.gsub(/([^_])_([^_])/, "\\1/\\2")
        .sub(/\A_/, "/").gsub("__", "_").gsub("//", "/")
      block.call(File.join(pth, relative_path), f, original_path)
    end
  end

  def self.yast_overlays
    # /usr/share/YaST2/ needs to be handled specially, it is writable
    # but contains symlinks to read-only subdirectories
    YAST_OVERLAYS + Dir["/usr/share/YaST2/*"].each_with_object([]) do |f, arr|
      arr << f if File.directory?(f) && !File.writable?(f)
    end
  end
end

# a generic HTTP downloader
class Downloader
  include YLogger
  attr_reader :url

  def initialize(url)
    @url = url
  end

  # download the file, returns the response body or if a block is
  # given it passes the response to it
  def download(redirect = 10, &block)
    log.info "Downloading #{url}"
    uri = URI(url)

    while redirect > 0
      Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.is_a?(URI::HTTPS)) do |http|
        request = Net::HTTP::Get.new uri
        http.request(request) do |response|
          if response.is_a?(Net::HTTPRedirection)
            log.info "Redirected to #{response["location"]}"
            uri = URI(response["location"])
            redirect -= 1
          elsif response.is_a?(Net::HTTPSuccess)
            if block_given?
              return block.call(response)
            else
              # read the rest of the response (the body)
              return response.read_body
            end
          else
            log.error "Download failed, error code: #{response.code}"
            return
          end
        end
      end
    end
  end
end

# specialized tarball downloader, it can extract the downloaded
# tarball on the fly (without saving the actual tarball) to the target directory
class TarballDownloader < Downloader
  def initialize(url)
    super
  end

  # start the downloading, extract the tarball to the specified directory
  def extract_to(dir)
    download do |response|
      if response["content-type"] =~ /application\/(x-|)gzip/
        # pipe the response body directly to the tar process
        IO.popen(["tar", "-C", dir, "--warning=no-timestamp", "-xz"], "wb") do |io|
          response.read_body do |chunk|
            io.write chunk
          end
        end
      else
        log.error "Unknown MIME type: #{response["content-type"]}"
      end
    end
  end
end

# specialized tarball downloader which can download the sources
# from GitHub (the "git" tool is missing in the inst-sys)
class GithubDownloader < TarballDownloader
  attr_reader :repo, :branch

  def initialize(repo, branch)
    super("https://github.com/#{repo}/archive/#{branch}.tar.gz")
    @repo = repo
    @branch = branch
  end
end

# installing Ruby gems using the "gem" tool
class GemInstaller
  # we need this gem for running the "rake install" command
  NEEDED_GEM = "yast-rake".freeze

  # is the gem installed?
  def gem_installed?(gem_name)
    gem(gem_name)
    true
  rescue Gem::LoadError
    false
  end

  # find the needed gems for running "rake install"
  def required_gems
    gems = [NEEDED_GEM]
    # handle the rake gem specifically, it is present in the system, but
    # the /usr/bin/rake file is missing
    gems << "rake" if !File.exist?("/usr/bin/rake")
    gems
  end

  # install the YaST required gems
  def install_required_gems
    install_gems(required_gems)
  end

  # install the specified gems
  def install_gems(gem_names)
    gem_names.each do |g|
      next if gem_installed?(g)

      add_gem_overlay
      system("gem install --no-document --no-format-exec #{gem_names.map(&:shellescape).join(" ")}")
    end
  end

  # make sure that the gem directory is writable
  def add_gem_overlay
    overlay = OverlayFS.new(Gem.dir)
    overlay.create
  end
end

# install the YaST sources using the "rake install" call
class Installer
  include YLogger

  # globs for ignored some files
  SKIP_FILES = [
    # vim temporary files
    "*/.*swp",
    # backup files
    "*/*.bak",
    # skip documentation
    "/usr/share/doc/*",
    # skip manual pages
    "/usr/share/man/*",
    # skip sysconfig templates
    "/usr/share/fillup-templates/*"
  ].freeze

  # install the sources to the specified (temporary) directory
  def install_sources(src, target)
    log.info "Preparing files..."

    # check for Makefile.cvs, we cannot install packages using autotools
    makefile_cvs = Dir["#{src}/**/Makefile.cvs"].first
    if makefile_cvs
      raise "Found Makefile.cvs, autotools based packages cannot be installed"
    end

    rakefile = Dir["#{src}/**/Rakefile"].first

    if rakefile
      src = File.dirname(rakefile)
      Dir.chdir(src) do
        `rake install DESTDIR=#{target.shellescape} 2> /dev/null`
      end
    else
      raise "Rakefile not found, cannot install the package"
    end
  end

  # should be the file skipped?
  def skip_file?(file)
    SKIP_FILES.any? { |glob| File.fnmatch?(glob, file) }
  end

  # copy the changed files to the ins-sys
  def copy_to_system(src)
    log.info "Copying to system..."
    src_path = Pathname.new(src)
    cnt = 0
    Find.find(src) do |path|
      # TODO: what about symlinks or empty directories?
      next unless File.file?(path)

      relative_path = Pathname.new(path).relative_path_from(src_path).to_s
      system_file = File.absolute_path(relative_path, "/")
      system_dir = File.dirname(system_file)

      if skip_file?(system_file)
        log.debug "Skipping: #{system_file}"
        next
      end

      if File.exist?(system_file)
        if FileUtils.identical?(system_file, path)
          log.debug "Not modified: #{system_file}"
          next
        else
          add_overlay(system_dir)
          FileUtils.rm_f(system_file) if File.symlink?(system_file)
          FileUtils.cp(path, system_file)
          log.warn "Updated: #{system_file}"
          cnt += 1
        end
      else
        # ensure the directory is writable
        if File.exist?(system_dir)
          add_overlay(system_dir)
        else
          # FIXME: maybe an overlay is needed for the upper directory...
          FileUtils.mkdir_p(system_dir)
        end

        FileUtils.cp(path, system_file)
        log.warn "Added: #{system_file}"
        cnt += 1
      end
    end

    log.info "Number of modified files: #{cnt}"
  end

  # ensure that the target directory is writable
  def add_overlay(dir)
    o = OverlayFS.new(dir)
    o.create
  end
end

# update the script itself with the latest version from GitHub
class SelfUpdater
  include YLogger

  # replace itself
  def self.update!
    downloader = Downloader.new(SELF_UPDATE_URL)
    new_content = downloader.download
    if new_content && !new_content.empty?
      old_content = File.read(__FILE__)

      if old_content == new_content
        log.info "No changes found, the script is up to date"
      else
        o = OverlayFS.new(File.dirname(__FILE__))
        o.create
        File.write(__FILE__, new_content)

        new_version = `#{__FILE__} version`
        log.info "Updating the script from version #{Version.string} to #{new_version}"
      end
    else
      log.error "ERROR: Download failed"
    end
  end
end

# handler for the "overlay" command option
class OverlayCommand
  def initialize(argv)
    @argv = argv
  end

  def run
    command = @argv.shift

    case command
    when "list"
      puts OverlayFS.find_all.map(&:dir)
    when "create"
      dir = @argv.shift

      if dir
        ovfs = OverlayFS.new(dir)
        ovfs.create
      else
        OverlayFS.default_overlays.map(&:create)
      end
    when "reset"
      OverlayFS.find_all.map(&:delete)
    when "files"
      OverlayFS.find_all.map(&:print_files)
    when "diff"
      OverlayFS.find_all.map(&:print_diff)
    else
      InvalidCommand.new(command)
    end
  end
end

# inst-sys test
class InstSys
  # check if the script is running in the inst-sys,
  # the script might not work as expected in an installed system
  # and using OverlayFS is potentially dangerous
  def self.check!
    mounts = `mount`
    # the inst-sys uses tmpfs (RAM disk) for the root
    return if mounts =~ /^tmpfs on \/ type tmpfs/

    # exit immediately if running in an installed system
    $stderr.puts "ERROR: This script can only work in the installation system (inst-sys)!"
    exit 1
  end
end

# parse the command line options
class Options
  def self.parse(argv)
    command = argv.shift

    case command
    when "version"
      VersionCommand.new
    when "overlay"
      InstSys.check!
      OverlayCommand.new(argv)
    when "patch"
      InstSys.check!
      PatchCommand.new(argv)
    when "selfupdate"
      InstSys.check!
      SelfUpdateCommand.new
    when "servers"
      ServersCommand.new(argv)
    when "help", "--help", nil
      HelpCommand.new
    else
      InvalidCommand.new(command)
    end
  end
end

# handle the "version" command line option
class VersionCommand
  def run
    puts "#{File.basename($PROGRAM_NAME)} #{Version.string}"
  end
end

# handle the "selfupdate" command line option
class SelfUpdateCommand
  def run
    SelfUpdater.update!
  end
end

# handle the "servers" command line option
class ServersCommand
  def initialize(argv)
    @argv = argv
  end

  def run
    host = @argv.shift

    return 1 unless host

    servers = RemoteServer.find(host)
    servers.each do |s|
      puts "URL: #{s.url}, directory: #{s.dir}"
    end
  end
end

# handle the "patch" command line option
class PatchCommand
  include YLogger

  def initialize(argv)
    @argv = argv
  end

  def run
    arg1 = @argv.shift
    arg2 = @argv.shift

    return 1 unless arg1

    prepare_system

    if arg1 && arg2
      # update from github
      install_from_github(arg1, arg2)
    elsif arg1.start_with?("http")
      # upgrade from URL
      install_from_tar(arg1)
    else
      # otherwise treat it as a hostname providing a tarball server
      install_from_servers(arg1)
    end

    # TODO: only when something has been updated?
    disable_self_update
  end

private

  def install_from_github(repo, branch)
    # add the default "yast" GitHub organization if missing
    repo = "yast/#{repo}" unless repo.include?("/")
    downloader = GithubDownloader.new(repo, branch)
    install_tar(downloader)
  end

  def install_from_tar(url)
    downloader = TarballDownloader.new(url)
    install_tar(downloader)
  end

  def install_from_servers(hostname)
    servers = RemoteServer.find(hostname)

    servers.each do |s|
      log.info "Installing from #{s.url}..."
      url = "#{s.url}/archive/current.tar.gz"
      install_from_tar(url)
    end
  end

  def install_sources(src_dir)
    Dir.mktmpdir do |target_dir|
      i = Installer.new
      i.install_sources(src_dir, target_dir)
      i.copy_to_system(target_dir)
    end
  end

  def prepare_system
    OverlayFS.default_overlays.map(&:create)
    g = GemInstaller.new
    g.install_required_gems
  end

  def install_tar(downloader)
    Dir.mktmpdir do |download_dir|
      downloader.extract_to(download_dir)
      install_sources(download_dir)
    end
  end

  # /etc/install.inf key
  SELF_UPDATE_KEY = "SelfUpdate"

  # disable the self update in the install.inf file
  def disable_self_update
    inf = InstallInf.new
    return if inf[SELF_UPDATE_KEY] == "0"

    log.warn "Disabling the YaST SelfUpdate feature in install.inf!"
    inf[SELF_UPDATE_KEY] = "0"
    inf.write
  end
end

# handle invalid command line options
class InvalidCommand
  include YLogger

  def initialize(cmd)
    @cmd = cmd
  end

  def run
    $stderr.puts "ERROR: Invalid command: #{cmd}"
    1
  end
private
  attr_reader :cmd
end

# Query the remote server for the running servers
class RemoteServer
  attr_reader :url, :dir

  def initialize(url, dir)
    @url = url
    @dir = dir
  end

  def self.find(host)
    host += ":8000" unless host.include?(":")

    url = "http://#{host}/servers/index.json"
    u = URI(url)
    u.path = ""

    downloader = Downloader.new(url)
    JSON.parse(downloader.download).map do |server|
      u.port = server["port"]
      new(u.to_s, server["dir"])
    end
  end
end

# the main script application
class Application
  def run(argv = ARGV)
    cmd = Options.parse(argv)
    cmd.run
  # the global exception handler
  rescue Exception => e
    puts "ERROR: #{e.message}"
    exit 1
  end
end


# do not execute the script when the file is loaded by some other script
# e.g. by a test, allow testing parts of the code without executing it as a whole
if __FILE__ == $PROGRAM_NAME
  # main
  app = Application.new
  app.run
end

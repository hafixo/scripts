#!/usr/bin/env ruby

# This script updates the YaST files in the inst-sys
# with the files from GitHub.

require "digest/sha1"
require "fileutils"
require "find"
require "json"
require "pathname"
require "shellwords"
require "tmpdir"

SELF_UPDATE_URL = "https://raw.githubusercontent.com/lslezak/scripts/master/yast/yupdate/yupdate"

# TODO: commands:
#   yupdate patch <github_repo> <branch>
#   yupdate patch <url>
#   yupdate patch <hostname:port>
#
#   yupdate overlay list
#   yupdate overlay create [<dir>]
#   yupdate overlay reset
#   yupdate overlay files
#   yupdate overlay diff
#
#   yupdate selfupdate
#
#   yupdate version
#
#   yupdate help

def msg(message)
  puts message
end

def details(message)
  # FIXME: only when verbose is set
  # puts message if ....
end

class Version
  VERSION = "0.0.1"

  def self.sha
    Digest::SHA1.hexdigest(File.read($PROGRAM_NAME))[0..7]
  end

  def self.string
    "#{VERSION} (#{sha})"
  end
end

# Class for managing the overlayfs mounts
class OverlayFS
  OVERLAY_PREFIX = "/var/lib/YaST2/overlayfs".freeze

  YAST_OVERLAYS = [
    "/usr/lib/YaST2",
    "/usr/lib64/YaST2",
    "/usr/share/autoinstall",
    "/usr/share/applications/YaST2"
  ]

  attr_reader :dir

  def initialize(dir)
    # expand symlinks
    @dir = File.realpath(dir)
  end

  def create
    return if File.writable?(dir)
    msg("Adding overlay for #{dir}...")

    FileUtils.mkdir_p(upperdir)
    FileUtils.mkdir_p(workdir)
    FileUtils.mkdir_p(origdir)

    # make the original content available in a separate directory
    system("mount --bind #{dir.shellescape} #{origdir.shellescape}")
    # mark the mount as a private otherwise the overlay would propagate
    # through the bind mount and we would see the changed content here
    system("mount --make-private #{origdir.shellescape} ")

    system("mount -t overlay overlay -o lowerdir=#{dir.shellescape}," \
      "upperdir=#{upperdir.shellescape},workdir=#{workdir.shellescape} #{dir.shellescape}")
  end

  def delete
    puts "umount #{dir}"
    system "umount #{dir.shellescape}"

    puts "umount #{origdir}"
    system "umount #{origdir.shellescape}"

    FileUtils.rm_rf([ upperdir, workdir, origdir ])
  end

  def print_files
    modified_files { |f, _modif, _orig| puts f}
  end

  def print_diff
    modified_files do |f, _modif, orig|
      next unless File.exist?(f) && File.exist?(orig)
      system("diff -u #{orig.shellescape} #{f.shellescape}")
    end
  end

  def self.find_all
    mounts = `mount`
    mounts.lines.each_with_object([]) do |line, arr|
      arr << new(Regexp.last_match[1]) if line =~ /^overlay on (.*) type overlay /
    end
  end

  def self.default_overlays
    yast_overlays.map{ |o| new(o) }
  end

private

  def dir_name
    # escape _ (double) for correct reverse conversion
    dir.gsub("_", "__").tr("/", "_")
  end

  def upperdir
    File.join(OVERLAY_PREFIX, "upper", dir_name)
  end

  def workdir
    File.join(OVERLAY_PREFIX, "workdir", dir_name)
  end

  def origdir
    File.join(OVERLAY_PREFIX, "original", dir_name)
  end

  def modified_files(&block)
    return unless block_given?

    Find.find(upperdir) do |f|
      next unless File.file?(f)
      upperdir_path = Pathname.new(upperdir)
      relative_path = Pathname.new(f).relative_path_from(upperdir_path)
      original_path = File.join(origdir, relative_path)
      # unescape _
      pth = upperdir_path.basename.to_s.gsub(/([^_])_([^_])/, "\\1/\\2")
        .sub(/\A_/, "/").gsub("__", "_").gsub("//", "/")
      block.call(File.join(pth, relative_path), f, original_path)
    end
  end

  def self.yast_overlays
    # /usr/share/YaST2/ needs to be handled specially, it is writable
    # but contains symlinks to read-only subdirectories
    YAST_OVERLAYS + Dir["/usr/share/YaST2/*"].each_with_object([]) do |f, arr|
      arr << f if File.directory?(f) && !File.writable?(f)
    end
  end
end

class Downloader
  def download_tar_archive(url, dir)
    msg("Downloading #{url}...")
    Dir.chdir(dir) do
      system("curl -L -s #{url.shellescape} | tar -xz")
    end
  end

  def download_gh_archive(repo, branch, dir)
    url = "https://github.com/#{repo}/archive/#{branch}.tar.gz"
    download_tar_archive(url, dir)
  end
end

class GemInstaller
  # we need this gem for running the "rake install" command
  NEEDED_GEM = "yast-rake".freeze

  def gem_installed?(gem_name)
    gem(gem_name)
    true
  rescue Gem::LoadError
    false
  end

  def required_gems
    gems = [NEEDED_GEM]
    # handle the rake gem specifically, it is present in the system, but
    # the /usr/bin/rake file is missing
    gems << "rake" if !File.exist?("/usr/bin/rake")
    gems
  end

  def install_required_gems
    install_gems(required_gems)
  end

  def install_gems(gem_names)
    gem_names.each do |g|
      next if gem_installed?(g)

      add_gem_overlay
      system("gem install --no-document --no-format-exec #{gem_names.map(&:shellescape).join(" ")}")
    end
  end

  def add_gem_overlay
    overlay = OverlayFS.new(Gem.dir)
    overlay.create
  end
end

class Installer
  # globs for ignored files
  SKIP_FILES = [
    # vim temporary files
    "*/.*swp",
    # backup files
    "*/*.bak",
    # skip documentation
    "/usr/share/doc/*",
    # skip manual pages
    "/usr/share/man/*",
    # skip sysconfig templates
    "/usr/share/fillup-templates/*"
  ].freeze

  def install_sources(src, target)
    msg("Preparing files...")
    rakefile = Dir["#{src}/**/Rakefile"].first

    if rakefile
      src = File.dirname(rakefile)
      Dir.chdir(src) do
        `rake install DESTDIR=#{target.shellescape} 2> /dev/null`
      end
    else
      $stderr.puts "ERROR: Rakefile not found"
    end
  end

  def skip_file?(file)
    SKIP_FILES.any? { |glob| File.fnmatch?(glob, file) }
  end

  def copy_to_system(src)
    msg("Copying to system...")
    src_path = Pathname.new(src)
    cnt = 0
    Find.find(src) do |path|
      # TODO: what about symlinks or empty directories?
      next unless File.file?(path)

      relative_path = Pathname.new(path).relative_path_from(src_path).to_s
      system_file = File.absolute_path(relative_path, "/")
      system_dir = File.dirname(system_file)

      if skip_file?(system_file)
        details("Skipping: #{system_file}")
        next
      end

      if File.exist?(system_file)
        if FileUtils.identical?(system_file, path)
          details("Not modified: #{system_file}")
          next
        else
          add_overlay(system_dir)
          FileUtils.rm_f(system_file) if File.symlink?(system_file)
          FileUtils.cp(path, system_file)
          msg("Updated: #{system_file}")
          cnt += 1
        end
      else
        # ensure the directory is writable
        if File.exist?(system_dir)
          add_overlay(system_dir)
        else
          # FIXME: maybe an overlay is needed for the upper directory...
          FileUtils.mkdir_p(system_dir)
        end

        FileUtils.cp(path, system_file)
        puts "Added: #{system_file}"
        cnt += 1
      end
    end

    msg("Number of modified files: #{cnt}")
  end
end

class SelfUpdater

  SELF_UPDATE_URL = "https://raw.githubusercontent.com/lslezak/scripts/master/yast/yupdate/yupdate"

  def self.update!
    msg("Downloading #{SELF_UPDATE_URL}...")
    new_content = `curl -L -s #{SELF_UPDATE_URL}`
    if $?.success?
      old_content = File.read($PROGRAM_NAME)

      if old_content == new_content
        msg("No changes found, the file is up to date")
      else
        o = OverlayFS.new(File.dirname($PROGRAM_NAME))
        o.create
        print "Updating the script from version #{Version::VERSION} to "
        File.write($PROGRAM_NAME, new_content)
        system("#{$PROGRAM_NAME} --version")
      end
    else
      $stderr.puts "ERROR: Download failed"
    end
  end
end

class OverlayCommand
  def initialize(argv)
    @argv = argv
  end

  def run
    command = @argv.shift

    case command
    when "list"
      puts OverlayFS.find_all.map(&:dir)
    when "create"
      dir = @argv.shift

      if dir
        ovfs = OverlayFS.new(dir)
        ovfs.create
      else
        OverlayFS.default_overlays.map(&:create)
      end
    when "reset"
      OverlayFS.find_all.map(&:delete)
    when "files"
      OverlayFS.find_all.map(&:print_files)
    when "diff"
      OverlayFS.find_all.map(&:print_diff)
    else
      InvalidCommand.new(command)
    end
  end
end

class InstSys
  def check_env
    mounts = `mount`
    return if mounts =~ /^tmpfs on \/ type tmpfs/

    $stderr.puts "ERROR: This script can only work in the installation system (int-sys)!"
    exit 1
  end
end

class HelpCommand
  def run
    name = File.basename($PROGRAM_NAME)
    puts <<-HELP
This is a helper script for updating the YaST installer in the installation system.

Usage:

#{name} <command>

Commands:

patch <github_repo> <branch>
patch <url>
patch <hostname[:port]>
overlay create [<dir>]  Create a new writable overlay for directory <dir>
overlay list            Print the created writable overlays
overlay reset           Remove all writable overlays restore the system to the original state
overlay files           Print the changed files (addd or removed files are not listed)
overlay diff
selfupdate              Update the script itself from
                        #{SELF_UPDATE_URL}
version                 Print the script version
help                    Print this help

WARNING: This script is intended only for testing and development purposes,
         using this tool makes the installation not supported!
See more details in [FIXME URL]
HELP
  end
end

class Options
  def self.parse(argv)
    command = argv.shift

    case command
    when "version"
      VersionCommand.new
    when "overlay"
      OverlayCommand.new(argv)
    when "patch"
      PatchCommand.new(argv)
    when "selfupdate"
      SelfUpdateCommand.new
    when "help", "--help", nil
      HelpCommand.new
    else
      InvalidCommand.new(command)
    end
  end
end

class VersionCommand
  def run
    puts "yupdate #{Version.string}"
  end
end

class SelfUpdateCommand
  def run
    SelfUpdater.update!
  end
end

class PatchCommand
  def initialize(argv)
    @argv = argv
  end

  def run
    arg1 = @argv.shift
    arg2 = @argv.shift

    return 1 unless arg1

    prepare_system

    # update from github
    if arg1 && arg2
      install_from_github(arg1, arg2)
    # upgrade from URL
    elsif arg1.start_with?("http")
      install_from_tar(arg1)
    end
  end

  def install_from_github(repo, branch)
    # add the default "yast" GitHub organization if missing
    repo = "yast/#{repo}" unless repo.include?("/")

    Dir.mktmpdir do |download_dir|
      d = Downloader.new
      d.download_gh_archive(repo, branch, download_dir)
      install_sources(download_dir)
    end
  end

  def install_from_tar(url)
    Dir.mktmpdir do |download_dir|
      d = Downloader.new
      d.download_tar_archive(url, download_dir)
      install_sources(download_dir)
    end
  end

  def install_sources(src_dir)
    Dir.mktmpdir do |target_dir|
      i = Installer.new
      i.install_sources(src_dir, target_dir)
      i.copy_to_system(target_dir)
    end
  end

  def prepare_system
    OverlayFS.default_overlays.map(&:create)
    g = GemInstaller.new
    g.install_required_gems
  end
end

class InvalidCommand
  def initialize(cmd)
    @cmd = cmd
  end

  def run
    puts "ERROR: Invalid command: #{cmd}"
    1
  end
private
  attr_reader :cmd
end

class Application
  def run(argv = ARGV)
    cmd = Options.parse(argv)
    cmd.run
  end
end

app = Application.new
app.run

exit 0

def list_remote_servers(url)
  u = URI(url)
  u.path = ""
  JSON.parse(`curl -s #{url.shellescape}`).map do |port|
    u.port = port
    u.to_s
  end
end

DEFAULT_PORT = 8000
RAKE_ARCHIVE = "archive/current.tar.gz"

OptionParser.new do |parser|
  parser.on("-o", "--other-servers URL", "List other running remote servers") do |r|
    list_servers = r
    list_servers = "http://#{r}:#{DEFAULT_PORT}/servers/index.json" if !list_servers.start_with?("http")
  end

  parser.on("-s", "--sync URL", "Sync from server") do |s|
    sync = s
    sync = "http://#{sync}:#{DEFAULT_PORT}/#{RAKE_ARCHIVE}" if !sync.start_with?("http")
  end
end.parse!

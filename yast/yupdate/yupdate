#!/usr/bin/env ruby

# This script updates the YaST files in the inst-sys
# with the files from GitHub.

require "digest/sha1"
require "fileutils"
require "find"
require "json"
require "logger"
require "net/http"
require "pathname"
require "shellwords"
require "singleton"
require "socket"
require "tmpdir"
require "uri"

SELF_UPDATE_URL = "https://raw.githubusercontent.com/lslezak/scripts/master/yast/yupdate/yupdate"

# TODO:
#  - allow patching from a single server (optionally disable the server discovery)
#  - error handling
#  - add comments, code cleanup

class HelpCommand
  def run
    name = File.basename($PROGRAM_NAME)
    puts <<-HELP
This is a helper script for updating the YaST installer in the installation system.

Usage:

#{name} <command>

Commands:

patch <github_repo> <branch>
patch <tarball_url>
patch <hostname[:port]>

overlay create [<dir>]  Create a new writable overlay for directory <dir>,
                        if no directory is specified it creates overlays
                        for the default YaST directories
overlay list            Print the created writable overlays

overlay reset           Remove all writable overlays, restore the system to
                        the original state

overlay files           Print the changed files (removed files are not listed)

overlay diff            Print the diff of the changed overlay files

selfupdate              Update the script itself from
                        #{SELF_UPDATE_URL}
version                 Print the script version

help                    Print this help

WARNING: This script is intended only for testing and development purposes,
         using this tool makes the installation not supported!
See more details in [TODO README URL]
HELP
  end
end

# A Ruby Logger which logs in usual Yast y2log format,
# additionally it prints the messages also to STDOUT
class YastLogger < Logger
  # redefine the format to the y2log format
  def format_message(severity, timestamp, progname, msg)
    puts msg
    # remove the function name from the caller location
    location = caller(3).first.gsub(/:in `.*'$/, "")
    "#{timestamp.strftime(datetime_format)} #{severity} #{Socket.gethostname}(#{Process.pid}) #{progname} #{location} #{msg}\n"
  end

  def initialize(*args)
    super
    self.datetime_format = "%Y-%m-%d %H:%M:%S"
    self.progname = "[#{File.basename($PROGRAM_NAME)}]"
    self.level = ENV["Y2DEBUG"] == "1" ? Logger::DEBUG : Logger::INFO
  end

private

  # redefine severity formatting
  def format_severity(severity)
    "<#{severity}>"
  end
end

# Provides the global shared Y2logger instance writing to /var/log/YaST2/y2log
# (or ~/.y2log if the file is not writable).
#
# It can be used for logging external Ruby code into y2log
class Y2Logger
  include Singleton

  Y2LOGFILE = "/var/log/YaST2/y2log".freeze

  attr_accessor :log

  def initialize
    # Yast compatibility - log to home if not running as root
    # (of if the file is not writable)
    if File.exist?(Y2LOGFILE)
      log_file = File.writable?(Y2LOGFILE) ? Y2LOGFILE : "#{ENV["HOME"]}/.y2log"
    else
      log_file = File.writable?(File.dirname(Y2LOGFILE)) ? Y2LOGFILE : "#{ENV["HOME"]}/.y2log"
    end

    # when creating the log file make sure it is readable only by the user
    # (it might contain sensitive data like passwords, registration code, etc.)
    File.write(log_file, "", perm: 0o600) unless File.exist?(log_file)

    @log = YastLogger.new(log_file)
  end
end

# This module provides access to Yast specific logging
#
# @example Use YastLogger in an easy way
#   class Foo
#     include YLogger
#
#     def foo
#       # this will be logged into y2log using the usual y2log format
#       log.debug "debug"
#       log.error "error"
#     end
#   end
module YLogger
  def log
    Y2Logger.instance.log
  end

  def self.included(base)
    base.extend self
  end
end

class Version
  STRING = "0.0.1"

  def self.string
    sha = Digest::SHA1.hexdigest(File.read($PROGRAM_NAME))[0..7]
    "#{STRING} (#{sha})"
  end
end

class InstallInf
  attr_reader :path

  def initialize(path = "/etc/install.inf")
    @path = path
    @values = File.read(path).lines.map(&:chomp)
  end

  def [](key)
    line = find_line(key)
    return nil unless line

    line.match(/^#{Regexp.escape(key)}:\s*(.*)/)[1]
  end

  def []=(key, val)
    line = find_line(key)

    if line
      # update the existing key
      line.replace("#{key}: #{val}")
    else
      # add a new key
      values << "#{key}: #{val}"
    end
  end

  def write
    File.write(path, values.join("\n"))
  end

private

  attr_reader :values

  def find_line(key)
    values.find{ |l| l.start_with?(key + ":") }
  end
end

# Class for managing the overlayfs mounts
class OverlayFS
  include YLogger

  OVERLAY_PREFIX = "/var/lib/YaST2/overlayfs".freeze

  YAST_OVERLAYS = [
    "/usr/lib/YaST2",
    "/usr/lib64/YaST2",
    "/usr/share/autoinstall",
    "/usr/share/applications/YaST2"
  ]

  attr_reader :dir

  def initialize(dir)
    # expand symlinks
    @dir = File.realpath(dir)
  end

  def create
    return if File.writable?(dir)
    log.warn "Adding overlay for #{dir}..."

    FileUtils.mkdir_p(upperdir)
    FileUtils.mkdir_p(workdir)
    FileUtils.mkdir_p(origdir)

    # make the original content available in a separate directory
    system("mount --bind #{dir.shellescape} #{origdir.shellescape}")
    # mark the mount as a private otherwise the overlay would propagate
    # through the bind mount and we would see the changed content here
    system("mount --make-private #{origdir.shellescape}")

    system("mount -t overlay overlay -o lowerdir=#{dir.shellescape}," \
      "upperdir=#{upperdir.shellescape},workdir=#{workdir.shellescape} #{dir.shellescape}")
  end

  def delete
    log.debug "umount #{dir}"
    system "umount #{dir.shellescape}"

    log.debug "umount #{origdir}"
    system "umount #{origdir.shellescape}"

    FileUtils.rm_rf([ upperdir, workdir, origdir ])
  end

  def print_files
    modified_files { |f, _modif, _orig| puts f}
  end

  def print_diff
    modified_files do |f, _modif, orig|
      next unless File.exist?(f) && File.exist?(orig)
      system("diff -u #{orig.shellescape} #{f.shellescape}")
    end
  end

  def self.find_all
    mounts = `mount`
    mounts.lines.each_with_object([]) do |line, arr|
      arr << new(Regexp.last_match[1]) if line =~ /^overlay on (.*) type overlay /
    end
  end

  def self.default_overlays
    yast_overlays.map{ |o| new(o) }
  end

private

  def dir_name
    # escape _ (double) for correct reverse conversion
    dir.gsub("_", "__").tr("/", "_")
  end

  def upperdir
    File.join(OVERLAY_PREFIX, "upper", dir_name)
  end

  def workdir
    File.join(OVERLAY_PREFIX, "workdir", dir_name)
  end

  def origdir
    File.join(OVERLAY_PREFIX, "original", dir_name)
  end

  def modified_files(&block)
    return unless block_given?

    Find.find(upperdir) do |f|
      next unless File.file?(f)
      upperdir_path = Pathname.new(upperdir)
      relative_path = Pathname.new(f).relative_path_from(upperdir_path)
      original_path = File.join(origdir, relative_path)
      # unescape _
      pth = upperdir_path.basename.to_s.gsub(/([^_])_([^_])/, "\\1/\\2")
        .sub(/\A_/, "/").gsub("__", "_").gsub("//", "/")
      block.call(File.join(pth, relative_path), f, original_path)
    end
  end

  def self.yast_overlays
    # /usr/share/YaST2/ needs to be handled specially, it is writable
    # but contains symlinks to read-only subdirectories
    YAST_OVERLAYS + Dir["/usr/share/YaST2/*"].each_with_object([]) do |f, arr|
      arr << f if File.directory?(f) && !File.writable?(f)
    end
  end
end

class Downloader
  include YLogger
  attr_reader :url

  def initialize(url)
    @url = url
  end

  def download(redirect = 10, &block)
    log.info "Downloading #{url}"
    uri = URI(url)

    while redirect > 0
      Net::HTTP.start(uri.host, uri.port, :use_ssl => uri.is_a?(URI::HTTPS)) do |http|
        request = Net::HTTP::Get.new uri
        http.request(request) do |response|
          if response.is_a?(Net::HTTPRedirection)
            log.info "Redirected to #{response["location"]}"
            uri = URI(response["location"])
            redirect -= 1
          elsif response.is_a?(Net::HTTPSuccess)
            if block_given?
              return block.call(response)
            else
              return response.read_body
            end
          else
            log.error "Download failed, error code: #{response.code}"
            return
          end
        end
      end
    end
  end
end

class TarballDownloader < Downloader
  def initialize(url)
    super
  end

  def extract_to(dir)
    download do |response|
      if response["content-type"] =~ /application\/(x-|)gzip/
        IO.popen(["tar", "-C", dir, "--warning=no-timestamp", "-xz"], "wb") do |io|
          response.read_body do |chunk|
            io.write chunk
          end
        end
      else
        log.error "Unknown MIME type: #{response["content-type"]}"
      end
    end
  end
end

class GithubDownloader < TarballDownloader
  attr_reader :repo, :branch

  def initialize(repo, branch)
    super("https://github.com/#{repo}/archive/#{branch}.tar.gz")
    @repo = repo
    @branch = branch
  end
end

class GemInstaller
  # we need this gem for running the "rake install" command
  NEEDED_GEM = "yast-rake".freeze

  def gem_installed?(gem_name)
    gem(gem_name)
    true
  rescue Gem::LoadError
    false
  end

  def required_gems
    gems = [NEEDED_GEM]
    # handle the rake gem specifically, it is present in the system, but
    # the /usr/bin/rake file is missing
    gems << "rake" if !File.exist?("/usr/bin/rake")
    gems
  end

  def install_required_gems
    install_gems(required_gems)
  end

  def install_gems(gem_names)
    gem_names.each do |g|
      next if gem_installed?(g)

      add_gem_overlay
      system("gem install --no-document --no-format-exec #{gem_names.map(&:shellescape).join(" ")}")
    end
  end

  def add_gem_overlay
    overlay = OverlayFS.new(Gem.dir)
    overlay.create
  end
end

class Installer
  include YLogger

  # globs for ignored files
  SKIP_FILES = [
    # vim temporary files
    "*/.*swp",
    # backup files
    "*/*.bak",
    # skip documentation
    "/usr/share/doc/*",
    # skip manual pages
    "/usr/share/man/*",
    # skip sysconfig templates
    "/usr/share/fillup-templates/*"
  ].freeze

  def install_sources(src, target)
    log.info "Preparing files..."
    rakefile = Dir["#{src}/**/Rakefile"].first

    if rakefile
      src = File.dirname(rakefile)
      Dir.chdir(src) do
        `rake install DESTDIR=#{target.shellescape} 2> /dev/null`
      end
    else
      log.error "ERROR: Rakefile not found"
    end
  end

  def skip_file?(file)
    SKIP_FILES.any? { |glob| File.fnmatch?(glob, file) }
  end

  def copy_to_system(src)
    log.info "Copying to system..."
    src_path = Pathname.new(src)
    cnt = 0
    Find.find(src) do |path|
      # TODO: what about symlinks or empty directories?
      next unless File.file?(path)

      relative_path = Pathname.new(path).relative_path_from(src_path).to_s
      system_file = File.absolute_path(relative_path, "/")
      system_dir = File.dirname(system_file)

      if skip_file?(system_file)
        log.debug "Skipping: #{system_file}"
        next
      end

      if File.exist?(system_file)
        if FileUtils.identical?(system_file, path)
          log.debug "Not modified: #{system_file}"
          next
        else
          add_overlay(system_dir)
          FileUtils.rm_f(system_file) if File.symlink?(system_file)
          FileUtils.cp(path, system_file)
          log.warn "Updated: #{system_file}"
          cnt += 1
        end
      else
        # ensure the directory is writable
        if File.exist?(system_dir)
          add_overlay(system_dir)
        else
          # FIXME: maybe an overlay is needed for the upper directory...
          FileUtils.mkdir_p(system_dir)
        end

        FileUtils.cp(path, system_file)
        log.warn "Added: #{system_file}"
        cnt += 1
      end
    end

    log.info "Number of modified files: #{cnt}"
  end

  def add_overlay(dir)
    o = OverlayFS.new(dir)
    o.create
  end
end

class SelfUpdater
  include YLogger

  def self.update!
    downloader = Downloader.new(SELF_UPDATE_URL)
    new_content = downloader.download
    if new_content && !new_content.empty?
      old_content = File.read($PROGRAM_NAME)

      if old_content == new_content
        log.info "No changes found, the script is up to date"
      else
        o = OverlayFS.new(File.dirname($PROGRAM_NAME))
        o.create
        File.write($PROGRAM_NAME, new_content)

        new_version = `#{$PROGRAM_NAME} version`
        log.info "Updating the script from version #{Version.string} to #{new_version}"
      end
    else
      log.error "ERROR: Download failed"
    end
  end
end

class OverlayCommand
  def initialize(argv)
    @argv = argv
  end

  def run
    command = @argv.shift

    case command
    when "list"
      puts OverlayFS.find_all.map(&:dir)
    when "create"
      dir = @argv.shift

      if dir
        ovfs = OverlayFS.new(dir)
        ovfs.create
      else
        OverlayFS.default_overlays.map(&:create)
      end
    when "reset"
      OverlayFS.find_all.map(&:delete)
    when "files"
      OverlayFS.find_all.map(&:print_files)
    when "diff"
      OverlayFS.find_all.map(&:print_diff)
    else
      InvalidCommand.new(command)
    end
  end
end

class InstSys
  def self.check!
    mounts = `mount`
    return if mounts =~ /^tmpfs on \/ type tmpfs/

    $stderr.puts "ERROR: This script can only work in the installation system (int-sys)!"
    exit 1
  end
end

class Options
  def self.parse(argv)
    command = argv.shift

    case command
    when "version"
      VersionCommand.new
    when "overlay"
      InstSys.check!
      OverlayCommand.new(argv)
    when "patch"
      InstSys.check!
      PatchCommand.new(argv)
    when "selfupdate"
      InstSys.check!
      SelfUpdateCommand.new
    when "servers"
      ServersCommand.new(argv)
    when "help", "--help", nil
      HelpCommand.new
    else
      InvalidCommand.new(command)
    end
  end
end

class VersionCommand
  def run
    puts "#{File.basename($PROGRAM_NAME)} #{Version.string}"
  end
end

class SelfUpdateCommand
  def run
    SelfUpdater.update!
  end
end

class ServersCommand
  def initialize(argv)
    @argv = argv
  end

  def run
    host = @argv.shift

    return 1 unless host

    r = RemoteServer.new
    servers = r.find(host)

    puts servers
  end
end

class PatchCommand
  include YLogger

  def initialize(argv)
    @argv = argv
  end

  def run
    arg1 = @argv.shift
    arg2 = @argv.shift

    return 1 unless arg1

    prepare_system

    if arg1 && arg2
      # update from github
      install_from_github(arg1, arg2)
    elsif arg1.start_with?("http")
      # upgrade from URL
      install_from_tar(arg1)
    else
      # otherwise treat it as a hostname providing a tarball server
      install_from_servers(arg1)
    end

    # TODO: only when something has been updated?
    disable_self_update
  end

private

  def install_from_github(repo, branch)
    # add the default "yast" GitHub organization if missing
    repo = "yast/#{repo}" unless repo.include?("/")
    downloader = GithubDownloader.new(repo, branch)
    install_tar(downloader)
  end

  def install_from_tar(url)
    downloader = TarballDownloader.new(url)
    install_tar(downloader)
  end

  def install_from_servers(hostname)
    remote = RemoteServer.new
    servers = remote.find(hostname)

    servers.each do |s|
      log.info "Installing from #{s}..."
      url = "#{s}/archive/current.tar.gz"
      install_from_tar(url)
    end
  end

  def install_sources(src_dir)
    Dir.mktmpdir do |target_dir|
      i = Installer.new
      i.install_sources(src_dir, target_dir)
      i.copy_to_system(target_dir)
    end
  end

  def prepare_system
    OverlayFS.default_overlays.map(&:create)
    g = GemInstaller.new
    g.install_required_gems
  end

  def install_tar(downloader)
    Dir.mktmpdir do |download_dir|
      downloader.extract_to(download_dir)
      install_sources(download_dir)
    end
  end

  # /etc/install.inf key
  SELF_UPDATE_KEY = "SelfUpdate"

  def disable_self_update
    inf = InstallInf.new
    return if inf[SELF_UPDATE_KEY] == "0"

    log.warn "Disabling the YaST SelfUpdate feature in install.inf!"
    inf[SELF_UPDATE_KEY] = "0"
    inf.write
  end
end

class InvalidCommand
  include YLogger

  def initialize(cmd)
    @cmd = cmd
  end

  def run
    $stderr.puts "ERROR: Invalid command: #{cmd}"
    1
  end
private
  attr_reader :cmd
end

class RemoteServer
  def find(host)
    host += ":8000" unless host.include?(":")

    url = "http://#{host}/servers/index.json"
    u = URI(url)
    u.path = ""

    downloader = Downloader.new(url)
    JSON.parse(downloader.download).map do |port|
      u.port = port
      u.to_s
    end
  end
end

class Application
  def run(argv = ARGV)
    cmd = Options.parse(argv)
    cmd.run
  end
end

app = Application.new
app.run
